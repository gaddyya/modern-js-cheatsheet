## Введение

### Мотивация
Этот документ представляет из себя памятку по возможностям JavaScript, с которыми вы будете часто сталкиваться в самых современных проектах и примерах кода.
Цель этого руководства - не обучить вас JavaScript с нуля, а помочь разработчикам с базовыми знаниями, которые при изучении современных кодовых баз (или, скажем, React) сталкиваются со сложностями из-за использованных в них концепций JavaScript.
Иногда я буду давать личные советы, которые могут быть спорными, но постараюсь упоминать, что это личное мнение.
> **Примечание:** Большинство представленных здесь понятий взяты из обновления языка JavaScript (ES2015, который часто называют ES6). Вы можете найти новые функции, добавленные в этом обновлении, [здесь](http://es6-features.org); они хорошо описаны.

### Дополнительные ресурсы
Если вам сложно разобраться с каким-то понятием, рекомендую искать ответы на вопросы на следующих ресурсах:
- [MDN (сеть разработчиков Mozilla)](https://developer.mozilla.org/fr/search?q=)
- [Вы не знаете JS (книга)](https://github.com/getify/You-Dont-Know-JS)
- [ES6 Особенности с примерами](http://es6-features.org)
- [Блог WesBos (ES6)](http://wesbos.com/category/es6/)
- [Базовый Javascript для начинающих](https://www.udacity.com/course/javascript-basics--ud804) - курс бесплатного обучения
- [Reddit (JavaScript)](https://www.reddit.com/r/javascript/)
- [Google](https://www.google.com/) для поиска специализированных блогов и ресурсов
- [StackOverflow](https://stackoverflow.com/questions/tagged/javascript)

### Объявление переменных: var, const, let
В JavaScript есть три ключевых слова, отвечающих за объявление переменных, и у каждого из них свои особенности. Эти слова - "var", "let" и "const".

#### Краткое объяснение
Переменным, объявленным с помощью ключевого слова ```const```, нельзя позднее присвоить новое значение, в то время как переменным, объявленным с помощью ```let``` или ```var```, можно.
Я рекомендую всегда объявлять переменные ключевым словом "const", а "let" использовать только в том случае, если позже эту переменную понадобится *изменить* или переопределить.
<table>
<tr>
<th></th>
<th>Область видимости</th>
<th>Можно переопределять</th>
<th>Можно изменять</th>
<th><a href="#tdz_sample">Временная мертвая зона</a></th>
</tr>
<tr>
<th>const</th>
<td>Блок</td>
<td>Нет</td>
<td><a href="#const_mutable_sample">Да</a></td>
<td>Да</td>
</tr>
<tr>
<th>let</th>
<td>Блок</td>
<td>Да</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<th>var</th>
<td>Функция</td>
<td>Да</td>
<td>Да</td>
<td>Нет</td>
</tr>
</table>

#### Пример кода
```javascript
const person = "Коля";
person = "Ваня" // Вызовет ошибку, переменной "person" нельзя присвоить новое значение
```
```javascript
let person = "Коля";
person = "Ваня";
console.log(person) // "Ваня", присвоение нового значения разрешено в случае с let
```

#### Подробное объяснение
[*Область видимости*](#scope_def) переменной определяет, где эта переменная доступна в коде.

##### var
Областью видимости переменных, объявленных с помощью ```var```, является функция. Это означает, что если переменная была создана внутри функции, то у всего внутри этой функции есть доступ к этой переменной. Кроме того, переменная с областью видимости внутри функции недоступна за пределами этой функции.
Можно думать об этом вот так: если у переменной область видимости *Х*, то эта переменная - как бы свойство Х.
```javascript
function myFunction() {
var myVar = "Коля";
console.log(myVar); // "Коля" - к myVar есть доступ изнутри функции
}
console.log(myVar); // Undefined, извне доступа к myVar нет.
```
Вот несколько менее очевидный пример области видимости переменных:
```javascript
function myFunction() {
var myVar = "Коля";
if (true) {
var myVar = "Ваня";
console.log(myVar); // "Ваня"
// действительно, myVar имеет область видимости внутри функции, мы всего лишь удалили предыдущее значение переменной myVar "Коля" и заменили его на "Ваня"}
console.log(myVar); // "Ваня" - обратите внимание, как код в блоке "if" повлиял на это значение
}
console.log(myVar); // Undefined, переменная myVar недоступна за пределами функции, в которой определена.
```
Кроме этого, переменные, объявленные ключевым словом *var*, при исполнении кода перемещаются в начало области видимости. Это называется [поднятие переменных](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var#Поднятие_переменных).
Этот фрагмент кода:
```js
console.log(myVar) // undefined -- ошибок нет
var myVar = 2;
```
при исполнении понимается как:
```js
var myVar;
console.log(myVar) // undefined -- ошибок нет
myVar = 2;
```

##### let
```var``` и ```let``` очень похожи друг на друга, но переменные, объявленные словом ```let```:
- имеют в качестве области видимости блок
- **недоступны** до объявления
- не могут быть повторно объявлены в той же области видимости
Давайте разберем, насколько важна блоковая область видимости, на том же самом примере:
```javascript
function myFunction() {
let myVar = "Коля";
if (true) {
let myVar = "Ваня";
console.log(myVar); // "Ваня"
// Поскольку myVar имеет блоковую область видимости, здесь мы только что создали новую переменную myVar.
// Эта переменная недоступна вне блока и никаким образом не зависит
// от первой переменной myVar, которую мы создали до этого!
}
console.log(myVar); // "Коля" - обратите внимание: инструкции в блоке if НЕ повлияли на значение переменной
}
console.log(myVar); // Undefined, доступа к myVar извне функции нет.
```
<a name="tdz_sample"></a> Теперь посмотрим, что значит "переменные, объявленные словами "let" и "const", недоступны до их объявления":
```js
console.log(myVar) // вызывает ReferenceError !
let myVar = 2;
```
В отличие от переменных, объявленных с помощью *var*, если вы попытаетесь прочитать или записать переменную, объявленную с помощью *let* или *const*, до того, как ей будет присвоено значение, произойдёт ошибка. Этот феномен часто называют  [*Временной мёртвой зоной*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let).  
**Примечание:** строго говоря, объявления переменных с использованием *let* и *const* тоже поднимаются, однако их инициализация — нет. Они сделаны так, что использовать их до объявления нельзя. Поэтому интуитивно ощущается так, будто эти переменные не поднимаются, но это не так. Ищите больше информации в [этом очень подробном объяснении](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified), если хотите знать больше.
В дополнение к сказанному, вы не можете переобъявить переменную, объявленную с помощью *let*:
```js
let myVar = 2;
let myVar = 3; // Вызовет SyntaxError
```

##### const
Переменные, объявленные ключевым словом "const", ведут себя так же, как переменные, объявленные ключевым словом *let*, только их еще и нельзя переопределять.
Подводя итог, переменные, объявленные с помощью *const*:
- имеют в качестве области видимости блок
- недоступны до объявления
- не могут быть повторно объявлены в той же области видимости
- не могут быть переопределены
```js
const myVar = "Коля";
myVar = "Ваня" // вызовет ошибку, переопределять переменную нельзя.
```
```js
const myVar = "Коля";
const myVar = "Ваня" // вызовет ошибку, объявить переменную можно только один раз.
```
<a name="const_mutable_sample"></a> Но есть одна тонкость: переменные, объявленные с помощью ```const```не являются [**неизменными**](#mutation_def)! Конкретно это означает, что *объекты* и *массивы*, объявленные с помощью ```const```, **могут** быть изменены.
В случае объектов:
```js
const person = {
name: 'Коля'
};
person.name = 'Ваня' // сработает! Переменная person не полностью переопределяется, а просто меняется
console.log(person.name) // "Ваня"
person = "Сандра" // вызовет ошибку, потому что переменные, объявленные словом "const", переопределять нельзя
```
В случае массивов:
```js
const person = [];
person.push('Ваня'); // сработает!  Переменная person не полностью переопределяется, а просто меняется
console.log(person[0]) // "Ваня"
person = ["Коля"] // вызовет ошибку, потому что переменные, объявленные словом "const", переопределять нельзя
```

#### Внешние ресурсы
- [Область видимости let и const в JavaScript - WesBos](http://wesbos.com/javascript-scoping/)
- [Демистификация временной мертвой зоны](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)

### <a name="arrow_func_concept"></a> Стрелочные функции
В обновлении ES6 JavaScript добавлены *стрелочные функции*, которые являются еще одним способом объявления и использования функций. Вот некоторые их преимущества:
- краткость;
- *this* берется из окружающего контекста;
- неявный возврат.

#### Пример кода
- Краткость и неявный возврат
```js
function double(x) { return x * 2; } // Обычный способ
console.log(double(2)) // 4
```
```js
const double = x => x * 2; // Та же функция, записанная в виде стрелочной функции с неявным возвратом
console.log(double(2)) // 4
```
- Обращение к *this*
Внутри стрелочной функции значение *this* равно значению *this* во внешней области видимости. В принципе, со стрелочными функциями вам больше не нужно делать трюк “that = this” перед вызовом функции внутри функции.
```js
function myFunc() {
this.myVar = 0;
setTimeout(() => {
this.myVar++;
console.log(this.myVar) // 1
}, 0);
}
```

#### Подробное объяснение

##### Краткость
Стрелочные функции по ряду причин короче, чем традиционные. Рассмотрим все возможные случаи:
- Явный и неявный возврат
**Явный возврат** - это функция, в теле которой используется ключевое слово **return**.
```js
function double(x) {
return x * 2; // эта функция явно возвращает x * 2, использовано ключевое слово *return*
}
```
При традиционном способе написания функций возврат всегда был явным. Со стрелочными функциями его можно сделать *неявным*. Это значит, что для возврата значения не нужно писать ключевое слово *return*.
Чтобы возврат значения был неявным, код функции должен быть написан в виде однострочного выражения.
```js
const double = (x) => {
return x * 2; // Явный возврат
}
```
Поскольку здесь нет ничего, кроме возвращаемого значения, возврат можно сделать неявным.
```js
const double = (x) => x * 2;
```
Для этого нам просто нужно **убрать фигурные скобки** и ключевое слово **return**. Поэтому это и называется *неявным* возвратом: ключевого слова *return* нет, но функция все равно вернет ```x * 2```.
> **Примечание**: Если ваша функция не возвращает никаких значений (с *побочными эффектами*), то в ней нет ни явного, ни неявного возврата.
- Только один аргумент
Если ваша функция принимает только один параметр, вы можете опустить скобки вокруг него. Если мы вернемся к функции *double* в коде выше:  
```js
const double = (x) => x * 2; // эта стрелочная функция принимает только один параметр
```
Скобки вокруг этого параметра могут быть отброшены:
```js
const double = x => x * 2; // эта стрелочная функция принимает только один параметр
```
- Без аргументов
Когда стрелочная функция вообще не принимает никаких аргументов, нужно написать пустые скобки, иначе синтаксис будет неверным.
```js
() => { // Скобки есть, все хорошо
const x = 2;
return x;
}
```
```js
=> { // Скобок нет, так работать не будет!
const x = 2;
return x;
}
```

##### Обращение к *this*
Чтобы понять эту тонкость, представленную стрелочными функциями, вы должны понимать, как  [this](#this_def) ведёт себя в JavaScript.
В стрелочной функции значение *this* равно значению *this* внешнего окружения. Это означает, что стрелочная функция не создает новый *this*, а получает его из окружения.
Если вы не используете стрелочные функции и хотите получить доступ к переменной из *this* в функции внутри другой функции, вам придется использовать фокус с *that = this* или *self = this*.
Вот, к примеру, использование функции setTimeout внутри функции myFunc:
```js
function myFunc() {
this.myVar = 0;
var that = this; // Тот самый фокус *that = this*
setTimeout(
function() { // В этой области видимости функции создается новый *this*
that.myVar++;
console.log(that.myVar) // 1
console.log(this.myVar) // undefined -- см. объявление функции выше
},
0
);
}
```
Но в случае стрелочных функций *this* берется из окружения:
```js
function myFunc() {
this.myVar = 0;
setTimeout(
() => { // this берется из окружения. В данном случае - из myFunc
this.myVar++;
console.log(this.myVar) // 1
},
0
);
}
```

#### Полезные ресурсы
- [Введение в стрелочные функции - WesBos](http://wesbos.com/arrow-functions/)
- [Стрелочные функции в JavaScript - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
- [Стрелочные функции и лексическое значение *this*](https://hackernoon.com/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4)

### Значение параметра функции по умолчанию
Начиная с обновления JavaScript ES2015, параметрам функции можно присваивать значения по умолчанию, используя следующий синтаксис:
```js
function myFunc(x = 10) {
return x;
}
console.log(myFunc()) // 10 -- никакое значение не передается, так что в myFunc х присваивается значение по умолчанию, т.е. 10
console.log(myFunc(5)) // 5 -- передается значение, так что в myFunc х присваивается значение 5
console.log(myFunc(undefined)) // 10 -- передается значение undefined, так что х присваивается значение по умолчанию
console.log(myFunc(null)) // null -- передается значение null. Подробнее см. ниже
```
Значения по умолчанию применяются только в двух случаях:
- не передано значение
- передано значение *undefined*
Другими словами, если передать в функцию параметр *null*, то параметр по умолчанию **не применится**.
> **Примечание:**: Присваивать значение по умолчанию можно в том числе и при работе с деструктурированными параметрами (см. пример в следующем понятии).

#### Внешние ресурсы
- [Значение параметра по умолчанию - Особенности ES6](http://es6-features.org/#DefaultParameterValues)
- [Параметры по умолчанию - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)

### Деструктуризация объектов и массивов
*Деструктуризация* — это удобный способ создавать новые переменные, напрямую получая значения из объектов или массивов.
На практике *деструктуризацию* можно использовать, чтобы присваивать переменные, разбивая на части параметры функции или *this.props* в React-проектах.

#### Объяснение с примером кода
- Объект
Давайте использовать во всех примерах следующий объект:
```js
const person = {
firstName: "Коля",
lastName: "Андреев",
age: 35,
sex: "М"
}
```
Без деструктуризации
```js
const first = person.firstName;
const age = person.age;
const city = person.city || "Санкт-Петербург";
```
С деструктуризацией всё поместится в одну строчку:
```js
const { firstName: first, age, city = "Санкт-Петербург" } = person; // И всё!
console.log(age) // 35 -- Создана новая переменная age и ей присвоено значение, равное person.age
console.log(first) // "Коля" -- Создана новая переменная first и ей присвоено значение, равное person.firstName
console.log(firstName) // Undefined -- person.firstName существует, НО новая созданная переменная называется first
console.log(city) // "Санкт-Петербург" -- Создана новая переменная city и, поскольку свойство person.city ранее не было определено, переменной присвоено альтернативное значение "Санкт-Петербург".
```
**Примечание:** В `const { age } = person;` скобки после ключевого слова *const* не используются для определения объекта или блока. Это синтаксис самой *деструктуризации*.
- Параметры функции
*Деструктуризация* часто используется, чтобы разбить на части параметры в функциях.
Без деструктуризации
```js
function joinFirstLastName(person) {
const firstName = person.firstName;
const lastName = person.lastName;
return firstName + '-' + lastName;
}
joinFirstLastName(person); // "Коля-Андреев"
```
Если деструктурировать параметр *person*, то функция выйдет куда короче:
```js
function joinFirstLastName({ firstName, lastName }) { // мы создали переменные firstName и lastName из частей параметра person
return firstName + '-' + lastName;
}
joinFirstLastName(person); // "Коля-Андреев"
```
Ещё удобнее использовать деструктуризацию со [стрелочными функциями](#arrow_func_concept):
```js
const joinFirstLastName = ({ firstName, lastName }) => firstName + '-' + lastName;
joinFirstLastName(person); // "Коля-Андреев"
```
- Массив
Давайте рассмотрим следующий массив:
```js
const myArray = ["a", "b", "c"];
```
Без деструктуризации
```js
const x = myArray[0];
const y = myArray[1];
```
С использованием деструктуризации
```js
const [x, y] = myArray; // И это всё!
console.log(x) // "a"
console.log(y) // "b"
```

#### Полезные ресурсы
- [Особенности ES6 - Деструктурирующее присваивание](http://es6-features.org/#ArrayMatching)
- [Деструктуризация объектов - WesBos](http://wesbos.com/destructuring-objects/)
- [ExploringJS - Деструктуризация](http://exploringjs.com/es6/ch_destructuring.html)

### Методы массивов - map / filter / reduce
*Map*, *filter* и *reduce* - это методы массивов, пришедшие из парадигмы  [*функционального программирования*](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0).
Перечислю их:
- **Array.prototype.map()** берет массив, делает что-то с его элементами. Возвращает массив трансформированных элементов.
- **Array.prototype.filter()** берёт массив, просматривает каждый элемент и решает, убрать его или оставить. Возвращает массив оставшихся значений.
- **Array.prototype.reduce()** берёт массив и вычисляет на основе элементов какое-то единое значение, которое и возвращает.
Я рекомендую пользоваться ими как можно чаще, следуя принципам функционального программирования, потому что они лаконичные, элегантные и их можно комбинировать.
Вооружившись этими тремя методами, вы можете обойтись без использования *for* и *forEach* в большинстве ситуаций. Когда в следующий раз соберётесь запустить цикл *for*, попробуйте решить задачу с помощью *map*, *filter* и *reduce*. Поначалу это будет трудно, потому что вам придётся научиться мыслить по-другому, но, разобравшись один раз, вы сможете применять эти методы без особых усилий.

#### Пример кода
```js
const numbers = [0, 1, 2, 3, 4, 5, 6];
const doubledNumbers = numbers.map(n => n * 2); // [0, 2, 4, 6, 8, 10, 12]
const evenNumbers = numbers.filter(n => n % 2 === 0); // [0, 2, 4, 6]
const sum = numbers.reduce((prev, next) => prev + next, 0); // 21
```
Давайте посчитаем сумму баллов всех студентов, которые набрали больше 10 баллов, используя *map*, *filter* и *reduce*:
```js
const students = [
{ name: "Коля", grade: 10 },
{ name: "Ваня", grade: 15 },
{ name: "Юля", grade: 19 },
{ name: "Наташа", grade: 9 },
];
const aboveTenSum = students
.map(student => student.grade) // создаём массив оценок из массива студентов с помощью метода map
.filter(grade => grade >= 10) // выбираем только оценки выше 10 при помощи метода filter
.reduce((prev, next) => prev + next, 0); // суммируем все оценки выше 10 друг с другом
console.log(aboveTenSum) // 44 -- 10 (Коля) + 15 (Ваня) + 19 (Юля), оценка Наташи меньше 10 и была проигнорирована
```

#### Объяснение
Давайте использовать в качестве примера следующий массив:
```js
const numbers = [0, 1, 2, 3, 4, 5, 6];
```

##### Array.prototype.map()
```js
const doubledNumbers = numbers.map(function(n) {
return n * 2;
});
console.log(doubledNumbers); // [0, 2, 4, 6, 8, 10, 12]
Что же здесь происходит? Мы применяем к массиву *numbers* метод .map, который взаимодействует с каждым элементом массива и передаёт его в нашу функцию. Цель функции - произвести расчёт и вернуть новое значение, чтобы map мог подставить его вместо переданного в функцию.
Давайте даже вынесем функцию из массива, чтобы было понятнее, что происходит:
```js
const doubleN = function(n) { return n * 2; };
const doubledNumbers = numbers.map(doubleN);
console.log(doubledNumbers); // [0, 2, 4, 6, 8, 10, 12]
```
```numbers.map(doubleN)``` создаёт ```[doubleN(0), doubleN(1), doubleN(2), doubleN(3), doubleN(4), doubleN(5), doubleN(6)]``` что равняется ```[0, 2, 4, 6, 8, 10, 12]```.
> **Примечание:** Если вы не хотите возвращать новый массив и просто хотите перебрать массив, совершая некоторые действия, то, возможно, вы захотите использовать просто for / forEach вместо метода map.

##### Array.prototype.filter()
```js
const evenNumbers = numbers.filter(function(n) {
return n % 2 === 0; // истинно, если "n" чётное, ложно если "n" нечетное
});
console.log(evenNumbers); // [0, 2, 4, 6]
```
Мы применяем .filter к массиву *numbers*, filter взаимодействует с каждым элементом массива и передаёт его в нашу функцию. Функция возвращает булево значение, что определяет, будет ли элемент сохранён в массиве. Затем filter возвращает массив отфильтрованных значений.

##### Array.prototype.reduce()
Цель метода reduce заключается в том, чтобы вычислить на основе массива какое-то одно значение. Какие именно вычисления метод произведет с элементами, зависит только от вас.
```js
const sum = numbers.reduce(
function(acc, n) {
return acc + n;
},
0 // значение аккумулирующей переменной на первом шаге цикла
);
console.log(sum) //21
```
Также как методы .map и .filter, метод .reduce применяется к массиву и в качестве первого параметра принимает функцию.
На этот раз, впрочем, кое-что изменилось:
- .reduce принимает два параметра
Первый параметр это функция, которая будет вызываться на каждом шаге цикла.
Второй параметр это значение аккумулирующей переменной (*acc* в нашем случае) на первом шаге цикла (чтобы разобраться, читайте далее)
- Параметры функции
Функция, которую вы передаёте в качестве первого параметра метода .reduce, принимает два параметра. Первый параметр - это аккумулирующая переменная (*acc* в нашем примере), второй параметр — текущий элемент.
Аккумулирующая переменная равна значению, возвращённому нашей функцией на **предыдущем** шаге цикла. В самом начале каждого цикла *acc* равна значению, которое вы передали в качестве второго параметра .reduce.

###### На первом шаге
```acc = 0``` потому что мы передали 0 в качестве второго параметра метода reduce
```n = 0``` это первый элемент массива *number*
Функция возвращает *acc* + *n* --> 0 + 0 --> 0

###### На втором шаге
```acc = 0``` потому что это значение функция вернула на предыдущем шаге
```n = 1``` это второй элемент массива *number*
Функция возвращает *acc* + *n* --> 0 + 1 --> 1

###### На третьем шаге
```acc = 1``` потому что это значение функция вернула на предыдущем шаге
```n = 2``` это третий элемент массива *number*
Функция возвращает *acc* + *n* --> 1 + 2 --> 3

###### На четвертом шаге
```acc = 3``` потому что это значение функция вернула на предыдущем шаге
```n = 3``` это четвёртый элемент массива *number*
Функция возвращает *acc* + *n* --> 3 + 3 --> 6

###### На последнем шаге
```acc = 15``` потому что это значение функция вернула на предыдущем шаге
```n = 6``` последний элемент массива *number*
Функция возвращает *acc* + *n* --> 15 + 6 --> 21
Поскольку это был последний шаг, **.reduce** возвращает 21.

#### Внешние ресурсы
- [Понимание методов map / filter / reduce в JS](https://hackernoon.com/understanding-map-filter-and-reduce-in-javascript-5df1c7eee464)

### Оператор расширения "..."
Оператор расширения "...", появившийся в ES2015, предназначен для раскрытия итерируемых объектов (например, массивов) там, где может поместиться несколько элементов таких объектов.

#### Пример кода
```js
const arr1 = ["a", "b", "c"];
const arr2 = [...arr1, "d", "e", "f"]; // ["a", "b", "c", "d", "e", "f"]
```
```js
function myFunc(x, y, ...params) {
console.log(x);
console.log(y);
console.log(params)
}
myFunc("a", "b", "c", "d", "e", "f")
// "a"
// "b"
// ["c", "d", "e", "f"]
```
```js
const { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
console.log(x); // 1
console.log(y); // 2
console.log(z); // { a: 3, b: 4 }
const n = { x, y, ...z };
console.log(n); // { x: 1, y: 2, a: 3, b: 4 }
```

#### Объяснение

##### В итерируемых объектах (наподобие массивов)
Если у нас есть два массива:
```js
const arr1 = ["a", "b", "c"];
const arr2 = [arr1, "d", "e", "f"]; // [["a", "b", "c"], "d", "e", "f"]
```
Первый элемент массива *arr2* - это массив, потому что *arr1* напрямую вставляется в *arr2*. Но мы хотим, чтобы *arr2* состоял только из букв. Чтобы добиться этого, мы можем *расширить* элементы массива *arr1* в массив *arr2*.
С использованием оператора расширения:
```js
const arr1 = ["a", "b", "c"];
const arr2 = [...arr1, "d", "e", "f"]; // ["a", "b", "c", "d", "e", "f"]
```

##### Оставшиеся параметры функции
Мы можем использовать оператор оставшихся параметров функции, чтобы вставить параметры в массив, элементы которого можно перебрать при помощи цикла. К каждой функции уже привязан объект **arguments** - это массив, состоящий из всех параметров, переданных функции.
```js
function myFunc() {
for (var i = 0; i < arguments.length; i++) {
console.log(arguments[i]);
}
}
myFunc("Коля", "Андреев", 10, 12, 6);
// "Коля"
// "Андреев"
// 10
// 12
// 6
```
Но давайте представим, что мы хотим, чтобы наша функция создала нового студента, у которого будут отдельные оценки и средний балл. Удобнее будет записать первые два параметра в две отдельные переменные, а все оценки поместить в массив, который можно перебирать.
Именно это позволяет нам сделать оператор оставшихся параметров!
```js
function createStudent(firstName, lastName, ...grades) {
// firstName = "Коля"
// lastName = "Андреев"
// [10, 12, 6] -- оператор "..." берет все остальные параметры, переданные функции, и создает переменную "grades" с массивом, в котором они хранятся.
const avgGrade = grades.reduce((acc, curr) => acc + curr, 0) / grades.length; // Высчитывает из всех оценок средний балл
return {
firstName: firstName,
lastName: lastName,
grades: grades,
avgGrade: avgGrade
}
}
const student = createStudent("Коля", "Андреев", 10, 12, 6);
console.log(student);
// {
// firstName: "Коля",
// lastName: "Андреев",
// grades: [10, 12, 6],
// avgGrade: 9,33
// }
```
> **Примечание:** createStudent - плохая функция, потому что мы не проверяем, существует ли grades.length и отличается ли от 0. Но так функцию легче прочитать, поэтому я этот случай не рассматриваю.

##### Расширение свойств объектов
Чтобы понять эту часть, рекомендую прочитать предыдущие объяснения о применении оператора оставшихся параметров к функциям и итерируемым объектам.
```js
const myObj = { x: 1, y: 2, a: 3, b: 4 };
const { x, y, ...z } = myObj; // деструктуризация объекта
console.log(x); // 1
console.log(y); // 2
console.log(z); // { a: 3, b: 4 }
// z - это остаток деструктурированного объекта: myObj минус деструктурированные свойства х и у.
const n = { x, y, ...z };
console.log(n); // { x: 1, y: 2, a: 3, b: 4 }
// Здесь свойства объекта z расширяются в n
```

#### Внешние ресурсы
- [TC39 - Объекты, расширение и оставшиеся параметры](https://github.com/tc39/proposal-object-rest-spread)
- [Введение в оператор расширения - WesBos](https://github.com/wesbos/es6-articles/blob/master/28%20-%20Spread%20Operator%20Introduction.md)
- [JavaScript и оператор расширения](https://codeburst.io/javascript-the-spread-operator-a867a71668ca)
- [6 отличных примеров использования оператора расширения](https://davidwalsh.name/spread-operator)

### Сокращенная запись свойств объектов
Когда вы записываете переменную в свойство объекта, если у переменной то же имя, что и у свойства, можно сделать следующее:
```js
const x = 10;
const myObj = { x };
console.log(myObj.x) // 10
```

#### Объяснение
Раньше (до ES2015), если вы хотели при объявлении нового *литерала объекта* использовать в качестве его свойств переменные, вам пришлось бы писать подобный код:
```js
const x = 10;
const y = 20;
const myObj = {
x: x, // запись значения переменной х в myObj.x
y: y // запись значения переменной у в myObj.y
};
console.log(myObj.x) // 10
console.log(myObj.y) // 20
```
Как видите, приходится повторять одно и то же, потому что имена свойств объекта совпадают с именами переменных, которые вы хотите записать в эти свойства.
С ES2015, если имя переменной совпадает с именем свойства, можно использовать такую сокращенную запись:
```js
const x = 10;
const y = 20;
const myObj = {
x,
y
};
console.log(myObj.x) // 10
console.log(myObj.y) // 20
```

#### Внешние ресурсы
[Сокращенная запись свойств - ES6 Features](http://es6-features.org/#PropertyShorthand)

### Промисы
Промис (promise) — это объект, который может быть синхронно возвращён из асинхронной функции ([ccskrf](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#3cd0)).
Промисы могут использоваться, чтобы избежать [глубоко вложенных колбэков](http://callbackhell.com/), и они всё чаще и чаще встречаются в современных JavaScript проектах.

#### Пример кода
```js
const fetchingPosts = new Promise((res, rej) => {
$.get("/posts")
.done(posts => res(posts))
.fail(err => rej(err));
});
fetchingPosts
.then(posts => console.log(posts))
.catch(err => console.log(err));
```

#### Пояснение
Когда вы делаете *AJAX-запрос*, ответ будет несинхронным, т.к. вы запрашиваете ресурс, на обработку которого требуется некоторое время. Вы также можете вообще не получить ответ, если он недоступен по какой-то причине (404).
Чтобы избежать таких ситуаций, в ES2015 были добавлены *промисы*. Промисы могут иметь 3 различных состояния:
- Выполняется
- Выполнено
- Отклонено
Предположим, мы хотим использовать промисы для обработки AJAX-запроса для извлечения ресурса X.

##### Создание промиса
Сначала нам нужно создать промис. Мы будем использовать GET-метод jQuery для создания AJAX-запроса к X.
```js
const xFetcherPromise = new Promise( // Создаём промис с помощью ключевого слова "new" и сохраняем его в переменную
function(resolve, reject) { // Конструктор промиса принимает в виде параметра функцию, которая, в свою очередь, принимает 2 параметра: resolve и reject
$.get("X") // Запускаем AJAX-запрос
.done(function(X) { // Как только запрос выполнен...
resolve(X); // ... выполняем промис с X в качестве значения
})
.fail(function(error) { // Если запрос не прошёл...
reject(error); // ... отклоняем промис со значением error
});
}
)
```
Как видно из рассмотренного примера, объект Promise принимает функцию, которая принимает два параметра: **resolve** и **reject**. Эти параметры - функции, которые при вызове изменяют состояние промиса со значения *выполняется* на *выполнено* или *отклонено*.
Промис находится в состоянии выполнения после создания экземпляра, и его функция-*исполнитель* выполняется немедленно. Как только одна из функций *выполнения* или *отклонения* вызвана в функции-*исполнителе*, промис вызовет связанные с ним обработчики.

##### Использование обработчиков промисов
Чтобы получить результат (или ошибку) промиса, мы должны присоединить к нему обработчики следующим образом:
```js
xFetcherPromise
  .then(function(X) {
    console.log(X);
  })
  .catch(function(err) {
    console.log(err)
  })
```
Если вызов прошёл успешно, вызывается *resolve*, и выполняется функция, переданная в метод ```.then```.
Если вызов не прошёл, вызывается *reject*и выполняется функция, переданная в ```.catch```.
> **Примечание :** Если обработчик присоединяется, когда промис уже был выполнен или отклонён, обработчик всё равно будет вызван. Так что нет никакой гонки между выполнением асинхронной операции и вызовом ее обработчиков. [(Ссылка: MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Description)

#### Внешние ресурсы
- [Промисы в JavaScript для чайников - Jecelyn Yeen](https://scotch.io/tutorials/javascript-promises-for-dummies)
- [API для промиса в JavaScript - David Walsh](https://davidwalsh.name/promises)
- [Использование промисов - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
- [Что такое промис - Eric Elliott](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261)
- [Промисы в JavaScript: Введение - Jake Archibald](https://developers.google.com/web/fundamentals/getting-started/primers/promises)
- [Документация по промисам - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

### Шаблонные строки
Шаблонные строки - это конструкция, позволяющая использовать [*интерполяцию выражений*](https://en.wikipedia.org/wiki/String_interpolation) в однострочных и многострочных строках.
Другими словами, это новый синтаксис записи строк, с которым удобно использовать любые выражения JavaScript (например, переменные).

#### Пример кода
```js
const name = "Коля";
`Привет, ${name}, следующее выражение равно четырем : ${2+2}`;
// Привет, Коля, следующее выражение равно четырем: 4
```

#### Внешние ресурсы
[Интерполяция строк - Особенности ES6](http://es6-features.org/#StringInterpolation)
[Шаблонные строки в ES6 - Addy Osmani](https://developers.google.com/web/updates/2015/01/ES6-Template-Strings)

### Шаблонные строки с тегами
Шаблонные теги - это *функции, которые могут быть приставкой к [шаблонной строке](#template-literals)*. Когда функция вызывается таким образом, первый параметр представляет собой массив *строк*, которые появляются между интерполированными переменными, а последующие параметры являются интерполированными значениями. Используйте оператор расширения `...`, чтобы захватить их все. [(Ссылка: MDN)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals).
> **Примечание :** Известная библиотека, которая называется [стилизованные компоненты](https://www.styled-components.com/), основана на этой возможности.
Ниже приведен пример их работы.
```js
function highlight(strings, ...values) {
const interpolation = strings.reduce((prev, next) => {
return prev + next + (values.shift() || "");
}, "");
return `<mark>${interpolation}</mark>`;
}
const meal = "круассаны";
const drink = "кофе";
highlight`Я люблю ${meal} с ${meal}.`;
// "<mark>Я люблю круассаны с кофе.</mark>"
```
Более интересный пример:
```js
function comma(strings, ...values) {
return strings.reduce((prev, next) => {
let value = values.shift() || [];
value = value.join(", ");
return prev + next + value;
}, "");
}
const snacks = ['яблоки', 'бананы', 'апельсины'];
comma`Я люблю ${snacks} на десерт.`;
// "Я люблю яблоки, бананы, апельсины на десерт."
```

#### Внешние ресурсы
- [Wes Bos по методу шаблонных строк с тегами](http://wesbos.com/tagged-template-literals/)
- [Библиотека общих шаблонных тегов](https://github.com/declandewet/common-tags)

### Импорт / экспорт
Модули в ES6 используются для получения доступа к переменным и функциям из других модулей, причем экспорт этих переменных и функций должен быть четко обозначен в исходном модуле.
Крайне рекомендую почитать ресурсы MDN об экспорте/импорте (см. внешние ресурсы ниже), в них содержится четкая и полная информация.

#### Объяснение с примером кода
- Именованный экспорт
Именованный экспорт используется для экспорта нескольких значений из модуля. Таким образом можно экспортировать только переменные (не функции и не классы), так что если вы хотите использовать именованную форму для экспорта функции, эту функцию нужно сначала записать в переменную.
```js
// mathConstants.js
export const pi = 3.14;
export const exp = 2.7;
export const alpha = 0.35;
// -------------
// myFile.js
import { pi, exp } from './mathConstants.js'; // Именованный импорт -- с синтаксисом, похожим на деструктуризацию
console.log(pi) // 3.14
console.log(exp) // 2.7
// -------------
// mySecondFile.js
import * as constants from './mathConstants.js'; // Все экспортированные значения записываются в переменную constants
console.log(constants.pi) // 3.14
console.log(constants.exp) // 2.7
```
- Импорт / экспорт по умолчанию
Экспорт по умолчанию может быть только один на каждый модуль. Это может быть функция, класс, объект или что-то еще. Это значение считается "главным", поскольку его будет проще всего импортировать [Ссылка: MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export#Description)
```js
// coolNumber.js
const ultimateNumber = 42;
export default ultimateNumber;
// ------------
// myFile.js
import number from './coolNumber.js';
// В переменную number автоматически попадает экспорт по умолчанию - вне зависимости от его имени в исходном модуле.
console.log(number) // 42
``
Экспорт функций:
```js
// sum.js
export default function sum(x, y) {
return x + y;
}
// -------------
// myFile.js
import sum from './sum.js';
const result = sum(1, 2);
console.log(result) // 3
```

#### Внешние ресурсы
- [Экспорт - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export)
- [Импорт - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)
- [Понимание модулей в ES6](https://www.sitepoint.com/understanding-es6-modules/)
- [Модули в JavaScript](http://exploringjs.com/es6/ch_modules.html#sec_modules-in-javascript)

### <a name="this_def"></a> *this* в JavaScript
Оператор *this* ведет себя не так, как в других языках. В большинстве случаев он определяется тем, как вызвана функция ([Ссылка: MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)).
Это сложное понятие с множеством тонкостей, так что я крайне рекомендую вам тщательно изучить приведенные ниже внешние ресурсы. Я покажу вам, как сам лично определяю, чему равно *this*. Этому меня научила [вот эта статья Иегуды Каца](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/).
```js
function myFunc() {
...
}
// После каждого выражения находим значение *this* в myFunc
myFunc.call("myString", "привет") // "myString" -- в *this* записывается значение первого параметра .call
// В non-strict-режиме
myFunc("привет") // window -- myFunc() - это синтаксический сахар для myFunc.call(window, "привет")
// В strict-режиме
myFunc("привет") // undefined -- myFunc() - это синтаксический сахар для myFunc.call(undefined, "привет")
```
```js
var person = {
myFunc: function() { ... }
}
person.myFunc.call(person, "test") // person Object -- в *this* записывается значение первого параметра call
person.myFunc("test") // person Object -- person.myFunc() - это синтаксический сахар для person.myFunc.call(person, "test")
var myBoundFunc = person.myFunc.bind("привет") // Создает новую функцию, в которой мы записываем "привет" в значение *this*
person.myFunc("test") // person Object -- Метод bind не влияет на первоначальный метод
myBoundFunc("test") // "hello" -- myBoundFunc - это person.myFunc, в которой *this* привязана к "привет"
```

#### Внешние ресурсы
- [Понимание вызова функций и "this" в JavaScript - Yehuda Katz
](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)
- [This в JavaScript - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

### Класс
JavaScript - это язык, [основанный на прототипах](https://en.wikipedia.org/wiki/Prototype-based_programming) (в то время как, например, Java - язык,  [основанный на классах](https://en.wikipedia.org/wiki/Class-based_programming)). В обновлении ES6 представлены классы JavaScript, которые являются синтаксическим сахаром для наследования на основе прототипов, а **не** новой моделью наследования классов ([Ссылка](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)).
Если вы знакомы с классами в других языках, слово "класс" может ввести вас в заблуждение. Постарайтесь не делать предположений о работе классов в JavaScript на основе других языков. Считайте это совершенно другим понятием.
Поскольку этот документ не является попыткой научить вас языку с нуля, я надеюсь, что вы знаете, что такое прототипы и как они себя ведут. Но вот несколько ссылок, которые мне показались полезными для понимания этого понятия:
- [Понимание прототипов в JS - Yehuda Katz](http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/)
- [Простой английский путеводитель по прототипам - Sebastian Porto](http://sporto.github.io/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/)
- [Наследование и цепочка прототипов - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

#### Примеры
До ES6, синтаксис на основе прототипов:
```js
var Person = function(name, age) {
this.name = name;
this.age = age;
}
Person.prototype.stringSentence = function() {
return "Привет, меня зовут " + this.name + " и мне " + this.age;
}
```
С ES6, синтаксис на основе классов:
constructor(name, age) {
this.name = name;
this.age = age;
}
stringSentence() {
return "Привет, меня зовут " + this.name + " и мне " + this.age;
}
}
const myPerson = new Person("Маша", 23);
console.log(myPerson.age) // 23
console.log(myPerson.stringSentence()) // "Привет, меня зовут Маша и мне 23
```

#### Внешние ресурсы
Для понимания прототипов:
- [Понимание прототипов в JS - Yehuda Katz](http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/)
- [Простой английский путеводитель по прототипам - Sebastian Porto](http://sporto.github.io/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/)
- [Наследование и цепочка прототипов - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
Для понимания классов:
- [ES6 Глубокое изучение классов - Nicolas Bevacqua](https://ponyfoo.com/articles/es6-classes-in-depth)
- [Особенности ES6 - Классы](http://es6-features.org/#ClassDefinition)
- [Классы JavaScript - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

### Async Await
Помимо [Промисов](#promises), вам может встретиться еще один синтаксис для обработки асинхронного кода - *async / await*.
Цель функций async/await - упрощение поведения при синхронном использовании промисов и выполнение какой-либо обработки группы промисов. Промисы похожи на структурированные обратные вызовы, а async/await точно так же похожи на комбинацию генераторов и промисов. ([Ссылка: MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function))
> **Примечание:** перед тем, как пытаться понять async / await, вы должны понимать, что такое промисы, и как они работают, поскольку async / await основаны на промисах.
> **Примечание 2:** [*await* должен использоваться в *async* функции](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9#f3f0), что означает, что вы не можете использовать await в верхнем уровне вашего кода, т.к. он не находится внутри async-функции.

#### Пример кода
```js
async function getGithubUser(username) { // ключевое слово async позволяет использование await в функции и означает, что функция возвращает промис
try { // Вот так обрабатываются ошибки с помощью async / await
const response = await fetch(`https://api.github.com/users/${username}`); // "синхронное" ожидание промиса перед переходом на новую строку
return response.json();
} catch (err) {
alert(err);
}
}
getGithubUser('mbeaudru').then(user => console.log(user)); // логирование пользователя - не может использовать синтаксис await, т.к. этот код не находится внутри async-функции
```

#### Объяснение с помощью примера кода
*Async / Await* построены на промисах, но они позволяют использовать более императивный стиль кода.
Оператор *async* превращает функцию в *промис*, в котором можно использовать оператор *await*.
```js
async function myFunc() {
// можно использовать оператор await, т.к. это async-функция
try {
return "Привет, мир!";
} catch(e) {
throw new Error();
}
}
myFunc().then(msg => console.log(msg)) // "Привет, мир!" -- myFunc превращается в промис из-за оператора async
```
Когда достигается оператор *return* async-функции, промис выполняется с возвращаемым значением. Если внутри async-функции выпадает ошибка, состояние промиса изменится на *rejected*.
Оператор  *await* используется для ожидания выполнения *Промиса* и может быть использован только в теле  *async*-функции. При этом выполнение кода приостанавливается, пока не будет выполнен промис.
> **Примечание :** *fetch* -- это Промис, который позволяет выполнить AJAX-запрос.
Давайте сначала посмотрим, как мы можем получить пользователя github с помощью промисов:
```js
function getGithubUser(username) {
return new Promise((resolve, reject) => {
fetch(`https://api.github.com/users/${username}`)
.then(response => {
const user = response.json();
resolve(user);
})
.catch(err => reject(err));
})
}
getGithubUser('mbeaudru')
.then(user => console.log(user))
.catch(err => console.log(err));
```
Вот эквивалент с использованием  *async / await*:
```js
async function getGithubUser(username) { // превращение в промис + разрешено использование ключевого слова await
try { // Мы обрабатываем ошибки в асинхронной функции с помощью try / catch
const response = await fetch(`https://api.github.com/users/${username}`); // Выполнение останавливается здесь, пока не закончится выполнение promise.
const user = response.json();
return user; // эквивалент разрешения промиса getGithubUser со значением user.
} catch (err) {
throw new Error(err); // эквивалент отклонения промиса getGithubUser со значением err.
}
}
getGithubUser('mbeaudru')
.then(user => console.log(user))
.catch(err => console.log(err));
```
Синтаксис *async / await* особенно удобен, когда вам нужно связывать взаимозависимые промисы.
Например, вам нужно получить token для того чтобы получить публикацию в блоге в базе данных, а затем информацию об авторе:
```js
async function fetchPostById(postId) {
try {
const token = await fetch('token_url');
const post = await fetch(`/posts/${postId}?token=${token}`);
const author = await fetch(`/users/${post.authorId}`);
post.author = author;
return post;
} catch(e) {
throw new Error(e);
}
}
fetchPostById('gzIrzeo64')
.then(post => console.log(post))
.catch(err => console.log(err));
```
> **Примечание :** Как вы видите, *try / catch* нужны для обработки ошибок. Но если вы используете *роутинг в express*, вы можете использовать middleware, чтобы избежать необходимости обработки ошибок и иметь приятный для чтения код. Смотрите [эту статью Alex Bazhenov](https://medium.com/@Abazhenov/using-async-await-in-express-with-node-8-b8af872c0016) для получения дополнительной информации.

#### Внешние ресурсы
- [Async/Await - JavaScript.Info](https://javascript.info/async-await)
- [ES7 Async/Await](http://rossboucher.com/await/#/)
- [6 причин, почему Async/Await в JavaScript заменит Промисы](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9)
- [awaits в JavaScript](https://dev.to/kayis/javascript-awaits)
- [Использование Async Await в Express с Node 8](https://medium.com/@Abazhenov/using-async-await-in-express-with-node-8-b8af872c0016)
- [Функция Async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
- [Await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)

### Истина / Ложь
В JavaScript "истинность" или "ложность" значения определяется при вычислении этого значения в булевом контексте. Примером булева контекста может быть вычисление в условии ```if```:
Любое значение будет приведено к ```true (истина)```, кроме:
- false (ложь)
- 0
- "" (пустая строка)
- null
- undefined
- NaN
Вот примеры *булева контекста*:
- значение условия ```if```
```js
if (myVar) {}
```
Значение ```myVar``` может быть любым [объектом первого класса](https://en.wikipedia.org/wiki/First-class_citizen) (переменная, функция, логическое значение), но оно будет переведено в логическое значение, поскольку оно вычисляется в булевом контексте.
- После логического оператора **NOT** ```!```
Этот оператор возвращает значение "ложь", если его единственный операнд может быть преобразован к значению "истина"; иначе он возвращает значение "истина".
```js
!0 // "истина" -- 0 - это "ложь", поэтому вернется "истина"
!!0 // "ложь" -- 0 - это "ложь", следовательно !0 возвращает истину, а !(!0) возвращает "ложь"
!!"" // "ложь"  -- пустая строка - "ложь", поэтому НЕ (НЕ "ложь") равно "истина"
```
- Конструктор объектов типа *Boolean*
```js
new Boolean(0) // "ложь"
new Boolean(1) // "истина"
```
- Тернарный оператор
```js
myVar ? "истина" : "ложь"
```
Значение myVar вычисляется в булевом контексте.

### Статические методы

#### Краткое объяснение
Ключевое слово `static` используется в классах для объявления статических методов. Статические методы - это функции в классе, которые принадлежат к объектам класса, и недоступны никаким экземплярам этого класса.

#### Пример кода
```js
class Repo{
static getName() {
return "Repo name is modern-js-cheatsheet"
}
}
//Обратите внимание, что нам не пришлось создавать экземпляр класса Repo
console.log(Repo.getName()) //Repo name is modern-js-cheatsheet
let r = new Repo();
console.log(r.getName()) //Не пойманный TypeError: repo.getName не является функцией
```

#### Подробное объяснение
Статические методы можно вызвать в другом статическом методе, используя ключевое слово `this`, однако это не работает для нестатических методов. Нестатические методы не могут напрямую обращаться к статическим методам, используя ключевое слово `this`.

##### Вызов статических методов из статического метода.
Для вызова статического метода из другого статического метода можно использовать ключевое слово `this` следующим образом:
```js
class Repo{
static getName() {
return "Repo name is modern-js-cheatsheet"
}
static modifyName(){
return this.getName() + '-added-this'
}
}
console.log(Repo.modifyName()) //Repo name is modern-js-cheatsheet-added-this
```

##### Вызов статических методов из нестатических методов.
Нестатические методы могут вызывать статические двумя способами:

1. ###### Используя имя класса.
Чтобы получить доступ к статическому методы из нестатического, используем имя класса и вызываем статический метод как обычное свойство, например, `ClassName.StaticMethodName`
```js
class Repo{
  static getName() {
    return "Repo name is modern-js-cheatsheet"
  }
  useName(){
    return Repo.getName() + ' and it contains some really important stuff'
  }
}
// нужно создать экземпляр класса для использования нестатических методов
let r = new Repo()
console.log(r.useName()) //Repo name is modern-js-cheatsheet and it contains some really important stuff
```

2. ###### Используя конструктор
Статические методы можно вызвать как свойства объекта-конструктора класса.
```js
class Repo{
static getName() {
return "Repo name is modern-js-cheatsheet"
}
useName(){
//Вызывает статический метод как обычное свойство конструктора
return this.constructor.getName() + ' and it contains some really important stuff'
}
}
// нужно создать экземпляр класса для использования нестатических функций
let r = new Repo()
console.log(r.useName()) //Repo name is modern-js-cheatsheet and it contains some really important stuff
```

#### Внешние ресурсы
- [Ключевое слово static - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static)
- [Статические методы - Javascript.info](https://javascript.info/class#static-methods)
- [Статические члены в ES6 - OdeToCode](http://odetocode.com/blogs/scott/archive/2015/02/02/static-members-in-es6.aspx)
## Глоссарий

### <a name="scope_def"></a> Область видимости
Контекст, в котором переменная и выражения являются "видимыми" или могут быть получены. Если переменная или выражение находятся "вне текущей области видимости", значит их нельзя использовать.
Источник: [MDN](https://developer.mozilla.org/en-US/docs/Glossary/Scope)

### <a name="mutation_def"></a> Изменение переменных
Говорят, что переменная изменилась, когда её значение изменилось относительно начального.
```js
var myArray = [];
myArray.push("firstEl") // значение myArray изменено
```
Переменная называется *неизменяемой*, если она не может быть изменена.
[Более подробно смотрите подробно в статье в MDN](https://developer.mozilla.org/en-US/docs/Glossary/Mutable).
